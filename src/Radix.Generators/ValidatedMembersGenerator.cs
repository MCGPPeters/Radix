using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Radix.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class ValidatedMembersGenerator : IIncrementalGenerator
{
    private const string GeneratedCodeAttribute = $"[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"Radix.Generators.ValidatedMembersGenerator\" , \"\")]";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var pipeline = context.SyntaxProvider
            .CreateSyntaxProvider(TypeHasValidatedMemberAttributes, SelectValidatedMemberAttributes)
            .Where(static results => results.Any());

        context.RegisterSourceOutput(pipeline, GenerateSourceCode);

    }

    private static void GenerateSourceCode(SourceProductionContext context, (ITypeSymbol memberTypeBeingValidated, ITypeSymbol validityType, ISymbol validatedType, object memberName)[] validatedMembersContext)
    {
        if (!validatedMembersContext.Any()) return;

        string namespaceName = validatedMembersContext[0].validatedType.ContainingNamespace.ToDisplayString();
        string typeName = validatedMembersContext[0].validatedType.Name;
        string privateConstructor = BuildPrivateConstructor(validatedMembersContext);
        string factoryMethod = BuildFactoryMethod(validatedMembersContext);

        string properties = validatedMembersContext
            .Select(x
                =>
                $@"
                {GeneratedCodeAttribute}
                public {x.memberTypeBeingValidated} {x.memberName} {{ get; init; }}
                "
            )
            .Aggregate((current, next) => $"{current}{Environment.NewLine}{Environment.NewLine}{next}");

        context.AddSource("validatedType",
            $@"
                // <autogenerated/>
                namespace {namespaceName}
                {{
                    using static global::Radix.Control.Validated.Extensions;
                    using global::Radix.Data;

                    public sealed partial record {typeName}
                    {{
                        {GeneratedCodeAttribute}
                        {privateConstructor}

                        {GeneratedCodeAttribute}
                        {factoryMethod}

                        {properties}
                    }}
                }}
            ");

    }

    private static string BuildFactoryMethod((ITypeSymbol memberTypeBeingValidated, ITypeSymbol validityType, ISymbol validatedType, object memberName)[] validatedMembersContext)
    {
        string validatedTypeName = validatedMembersContext[0].validatedType.Name;

        var newLambdaArguments = validatedMembersContext
            .Select(x
                => $"{x.memberTypeBeingValidated} {x.memberName.ToString()!.FirstCharacterToLowerCase()}_")
            .Aggregate((current, next) => $"{current}, {next}");

        var constructorParameters = validatedMembersContext
            .Select(x
                => $"{x.memberName.ToString()!.FirstCharacterToLowerCase()}_")
            .Aggregate((current, next) => $"{current}, {next}");

        string applyCallChain = validatedMembersContext
            .Select(x
                => $".Apply({x.validityType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.Validate(\"{x.memberName.ToString()!.FirstCharacterToLowerCase()}\")({x.memberName.ToString()!.FirstCharacterToLowerCase()}))")
            .Aggregate((current, next) => $"{current}{Environment.NewLine}{next}");

        return
            $@"
            public static Validated<{validatedTypeName}> Create({BuildArgumentList(validatedMembersContext)})
            {{
                var create = ({newLambdaArguments}) => new {validatedTypeName}({constructorParameters});

                return Valid(create)
                    {applyCallChain};
            }}
            ";
    }

    private static string BuildPrivateConstructor((ITypeSymbol memberTypeBeingValidated, ITypeSymbol validityType, ISymbol validatedType, object memberName)[] validatedMembersContext)
    {
        string validatedTypeName = validatedMembersContext[0].validatedType.Name;
        
        var argumentList = BuildArgumentList(validatedMembersContext); ;

        string setProperties = validatedMembersContext
            .Select(x
                => $"{x.memberName} = {x.memberName.ToString()!.FirstCharacterToLowerCase()};")
            .Aggregate((current, next) => $"{current}{Environment.NewLine}{Environment.NewLine}{next}");

        return
            @$"
            private {validatedTypeName} ({argumentList})
            {{
                {setProperties}
            }}
            ";
    }

    private static string BuildArgumentList((ITypeSymbol memberTypeBeingValidated, ITypeSymbol validityType, ISymbol validatedType, object memberName)[] validatedMembersContext) =>
        validatedMembersContext
            .Select(x
                => $"{x.memberTypeBeingValidated} {x.memberName.ToString()!.FirstCharacterToLowerCase()}")
            .Aggregate((current, next) => $"{current}, {next}");

    private static (ITypeSymbol memberTypeBeingValidated, ITypeSymbol validityType, ISymbol validatedType, object memberName)[] SelectValidatedMemberAttributes(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        SyntaxNode candidate = context.Node;
        var validatedType = context.SemanticModel.GetDeclaredSymbol(candidate, cancellationToken);
        var attributeSymbol = context.SemanticModel.Compilation.GetTypeByMetadataName("Radix.ValidatedMemberAttribute`2");
        var attributes = validatedType!
            .GetAttributes()
            .Where(attribute =>
                attribute.AttributeClass is not null
                && attribute.AttributeClass.Name.Equals(attributeSymbol!.Name));

        return attributes.Select(attribute =>
        {
            // get the Validity<T> subtype which holds the validator function (which is the second type argument of the Validated<T, V> attributes)
            var validityType = attribute.AttributeClass!.TypeArguments[1];

            // get the type we are validating (which is the first type argument of the Validated<t, V> attributes)
            var memberTypeBeingValidated = attribute.AttributeClass!.TypeArguments[0];

            var memberName = attribute.ConstructorArguments[0].Value!;

            // create the required source code
            return (memberTypeBeingValidated, validityType, validatedType, memberName);
        }).ToArray();
    }

    /// <summary>
    /// Find all records
    /// </summary>
    /// <param name="node"></param>
    /// <param name="cancellationToken"></param>
    /// <returns></returns>
    private bool TypeHasValidatedMemberAttributes(SyntaxNode node, CancellationToken cancellationToken)
    {
        return node is RecordDeclarationSyntax
               {
                   AttributeLists.Count: > 0
               } candidate
               && candidate.Modifiers.Any(SyntaxKind.PartialKeyword);
    }
}
