
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Diagnostics;

namespace Radix.Generators;


[Generator]
public class ConfigurationKeysGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        //Debugger.Launch();
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (syntaxNode, _) => syntaxNode is ClassDeclarationSyntax classDecl && classDecl.AttributeLists.Count > 0,
                transform: (syntaxContext, _) => (classDecl: (ClassDeclarationSyntax)syntaxContext.Node, model: syntaxContext.SemanticModel))
            .Where(pair => HasConfigurationAttribute(pair.classDecl, pair.model));

        var compilationAndClasses = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilationAndClasses, static (sourceProductionContext, source) =>
        {
            var (compilation, classes) = source;
            foreach (var (classSyntax, model) in classes.Distinct())
            {
                var className = classSyntax.Identifier.Text;
                var typeSymbol = model.GetDeclaredSymbol(classSyntax);
                var namespaceName = typeSymbol?.ContainingNamespace.ToDisplayString() ?? "global";
                var configurationKeysClassName = className + "ConfigurationKeys";
                var hintName = $"{configurationKeysClassName}_{Guid.NewGuid()}.g.cs";
                var sourceCode = GenerateConfigurationKeysClass(compilation, namespaceName, className, configurationKeysClassName, classSyntax, model);
                sourceProductionContext.AddSource(hintName, SourceText.From(sourceCode, Encoding.UTF8));
            }
        });
    }

    private static bool HasConfigurationAttribute(ClassDeclarationSyntax classSyntax, SemanticModel model)
    {
        var classSymbol = model.GetDeclaredSymbol(classSyntax);
        if (classSymbol is not null)
        {
            return classSymbol.GetAttributes().Any(ad => ad.AttributeClass is not null ? ad.AttributeClass.ToDisplayString() == "Radix.Generators.Attributes.ConfigurationAttribute" : false);
        }
        return false;
    }

    private static string GenerateConfigurationKeysClass(Compilation compilation, string namespaceName, string className, string configurationKeysClassName, ClassDeclarationSyntax classSyntax, SemanticModel model)
    {
        var stringBuilder = new StringBuilder();
        // Header comment indicating the code is auto-generated
        stringBuilder.AppendLine("// <auto-generated>");
        stringBuilder.AppendLine("// This code was generated by a tool.");
        stringBuilder.AppendLine("// Changes to this file may cause incorrect behavior and will be lost if");
        stringBuilder.AppendLine("// the code is regenerated.");
        stringBuilder.AppendLine("// </auto-generated>");
        stringBuilder.AppendLine();
        stringBuilder.AppendLine("using System;");
        stringBuilder.AppendLine("using System.Diagnostics;");
        stringBuilder.AppendLine("using System.CodeDom.Compiler;"); // Include namespace for GeneratedCodeAttribute
        stringBuilder.AppendLine();
        stringBuilder.AppendLine($"namespace {namespaceName}");
        stringBuilder.AppendLine("{");
        // Apply DebuggerNonUserCode and GeneratedCodeAttribute to the class
        stringBuilder.AppendLine("    [DebuggerNonUserCode]");
        stringBuilder.AppendLine("    [GeneratedCode(\"Radix.Generators.ConfigurationKeysGenerator\", \"1.0\")]"); // Adjust version as appropriate
        stringBuilder.AppendLine($"    /// <summary>");
        stringBuilder.AppendLine($"    /// Provides configuration key paths for the {className} class.");
        stringBuilder.AppendLine($"    /// </summary>");
        stringBuilder.AppendLine($"    public class {configurationKeysClassName}");
        stringBuilder.AppendLine("    {");

        var classSymbol = model.GetDeclaredSymbol(classSyntax);

        GenerateConfigurationKeysForType(stringBuilder, classSymbol!, className);

        stringBuilder.AppendLine("    }");
        stringBuilder.AppendLine("}");
        string v = stringBuilder.ToString();
        return v;
    }


    private static void GenerateConfigurationKeysForType(StringBuilder stringBuilder, INamedTypeSymbol classSymbol, string parentPath)
    {
        foreach (var property in classSymbol.GetMembers().OfType<IPropertySymbol>())
        {
            var propertyName = property.Name;
            var propertyPath = $"{parentPath}:{propertyName}";

            // Add property comment
            stringBuilder.AppendLine($"        /// <summary>");
            stringBuilder.AppendLine($"        /// Configuration key for {propertyName}.");
            stringBuilder.AppendLine($"        /// </summary>");
            stringBuilder.AppendLine($"        public static string {propertyPath.Replace(':', '_')} => \"{propertyPath}\";");

            if (property.Type.TypeKind == TypeKind.Class && property.Type.SpecialType != SpecialType.System_String)
            {
                GenerateConfigurationKeysForType(stringBuilder, (INamedTypeSymbol)property.Type, propertyPath);
            }
        }
    }

}
